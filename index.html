<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">

  <!-- CSP ultra-segura con nonce (igual que ten√≠as) -->
  <script>
    const nonce = btoa(String.fromCharCode(...crypto.getRandomValues(new Uint8Array(16))));
    document.head.insertAdjacentHTML(
      "beforeend",
      `<meta http="Content-Security-Policy"
        content="
          default-src 'self';
          script-src 'self' https://cdn.jsdelivr.net 'nonce-${nonce}';
          style-src 'self' 'unsafe-inline';
          img-src 'self' blob: data:;
          connect-src *;
          frame-ancestors 'none';
          media-src *;
          object-src 'none';
          base-uri 'self';
        ">
      `
    );
  </script>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Asistente Visual Inteligente</title>

  <!-- TensorFlow -->
  <script nonce="">
    document.currentScript.setAttribute("nonce", nonce);
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0" nonce=""></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd" nonce=""></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface" nonce=""></script>

  <style>
    body {
      background: #0d1117;
      color: #fff;
      text-align: center;
      margin: 0;
      padding: 20px 0;
      font-family: Arial;
    }
    video {
      width: 90%;
      max-width: 480px;
      border-radius: 14px;
      margin-top: 15px;
    }
    #status {
      margin-top: 20px;
      font-size: 1.3em;
      background: rgba(255,255,255,0.12);
      padding: 10px 20px;
      border-radius: 10px;
      display: inline-block;
    }
    #startButton {
      font-size: 1.5em;
      padding: 12px 25px;
      background: #2ea043;
      border: none;
      border-radius: 15px;
      color: white;
      cursor: pointer;
    }
    #notify {
      position: fixed;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.75);
      padding: 10px 18px;
      border-radius: 12px;
      opacity: 0;
      transition: 0.25s;
    }
  </style>
</head>

<body>

<h2>üëÅ Asistente Visual Inteligente</h2>
<button id="startButton">Iniciar Asistente</button>
<video id="video" autoplay playsinline></video>

<div id="status">Esperando inicio...</div>
<div id="notify"></div>

<script nonce="">
document.currentScript.setAttribute("nonce", nonce);

/* ---------- UI Utils ---------- */
function notify(msg) {
  const n = document.getElementById("notify");
  n.textContent = msg;
  n.style.opacity = 1;
  setTimeout(() => n.style.opacity = 0, 2200);
}

/* ---------- Variables ---------- */
let video = document.getElementById("video");
let statusDiv = document.getElementById("status");
let startBtn = document.getElementById("startButton");

let cocoModel = null;
let blazeModel = null;

let speaking = false;
let lastMessage = "";
let lastFrame = 0;

/* ---------- VOZ (id√©ntica a la tuya pero con cancel para evitar colas) ---------- */
function speak(msg) {
  if (!msg) return;
  if (msg === lastMessage) return; // no repetir exactamente el mismo mensaje
  try {
    speechSynthesis.cancel(); // evitar acumulaci√≥n en m√≥viles
    const u = new SpeechSynthesisUtterance(msg);
    u.lang = "es-MX";
    speaking = true;
    u.onend = () => { speaking = false; };
    speechSynthesis.speak(u);
    lastMessage = msg;
    statusDiv.textContent = msg;
  } catch (e) {
    console.warn("TTS error:", e);
  }
}

/* ---------- C√°mara (igual) ---------- */
async function setupCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: "environment",
        width: { ideal: 320 },
        height: { ideal: 240 }
      }
    });
    video.srcObject = stream;
  } catch (e) {
    speak("No se puede acceder a la c√°mara.");
    notify("No se puede acceder a la c√°mara.");
    throw e;
  }

  return new Promise(res => video.onloadedmetadata = () => res());
}

/* ---------- Cargar modelos (igual) ---------- */
async function loadModels() {
  statusDiv.textContent = "Cargando modelos‚Ä¶";
  await tf.ready();
  cocoModel = await cocoSsd.load({ base: "lite_mobilenet_v2" });
  blazeModel = await blazeface.load();
  statusDiv.textContent = "Modelos cargados ‚úî";
}

/* ---------- FILTRADO TEMPORAL (histeresis) ---------- */
/*
  B√°sico, y efectivo:
  - mantenemos contadores para cada condici√≥n
  - incrementan cuando condici√≥n presente, decrementan cuando no
  - s√≥lo consideramos una condici√≥n "activa" si su contador >= THRESH_GO
  - usamos THRESH_OFF para evitar conmutaciones frecuentes (histeresis)
*/
const COUNTER_MAX = 6;
const THRESH_GO = 3;   // cu√°ntos frames consecutivos para activar
const THRESH_OFF = 1;  // cu√°ntos frames sin detecci√≥n para desactivar

let personCount = 0;
let vehicleCount = 0;
let wallCount = 0;
let groundCount = 0;

/* ---------- Funciones de ayuda ---------- */
function clamp(n, min=0, max=COUNTER_MAX){ return Math.max(min, Math.min(max, n)); }

function isObstacleOnGroundAdaptive(obj, vw, vh) {
  // hacemos umbral relativo al √°rea del frame y tama√±o del objeto
  const [x,y,w,h] = obj.bbox;
  const area = w*h;
  // zona inferior: 60%..100% de la altura es "suelo"
  const bottom = y + h;
  const groundZone = vh * 0.65;
  return bottom > groundZone && area > (vw*vh*0.02); // 2% del frame
}

/* ---------- DETECCI√ìN PRINCIPAL (misma l√≥gica, con smoothing) ---------- */
async function detectFrame(timestamp) {
  // tasa de detecci√≥n controlada para m√≥viles
  if (timestamp - lastFrame < 320) { // ~3 FPS (ajustable)
    return requestAnimationFrame(detectFrame);
  }
  lastFrame = timestamp;

  // si modelos no listos, volver a planificar
  if (!cocoModel || !blazeModel) {
    return requestAnimationFrame(detectFrame);
  }

  // detecciones
  const cocoDet = await cocoModel.detect(video);
  const blazeDet = await blazeModel.estimateFaces(video, false);

  // mezcla resultados (igual que antes)
  const preds = [...cocoDet];
  blazeDet.forEach(face => {
    preds.push({
      class: "person",
      score: 0.9,
      bbox: [
        face.topLeft[0],
        face.topLeft[1],
        face.bottomRight[0] - face.topLeft[0],
        face.bottomRight[1] - face.topLeft[1]
      ]
    });
  });

  // dimensiones de video para umbrales adaptativos
  const vw = video.videoWidth || 320;
  const vh = video.videoHeight || 240;

  // condiciones actuales (frame actual)
  let personPresent = false;
  let vehiclePresent = false;
  let wallPresent = false;
  let groundPresent = false;

  // l√≥gica original (no modificada) ‚Äî pero usamos umbrales adaptativos y contadores
  for (const obj of preds) {
    const [x,y,w,h] = obj.bbox;
    const area = w*h;

    if (obj.class === "person" && area > Math.max(18000, vw*vh*0.02)) personPresent = true;
    if (["car","truck","bus"].includes(obj.class) && area > Math.max(25000, vw*vh*0.03)) vehiclePresent = true;
    if (area > vw * vh * 0.55) wallPresent = true;
    if (isObstacleOnGroundAdaptive(obj, vw, vh)) groundPresent = true;
  }

  // actualizar contadores con smoothing/histeresis
  personCount = clamp(personPresent ? personCount + 1 : personCount - 1);
  vehicleCount = clamp(vehiclePresent ? vehicleCount + 1 : vehicleCount - 1);
  wallCount = clamp(wallPresent ? wallCount + 1 : wallCount - 1);
  groundCount = clamp(groundPresent ? groundCount + 1 : groundCount - 1);

  // estados filtrados (solo true si contador >= THRESH_GO)
  const personStable = personCount >= THRESH_GO;
  const vehicleStable = vehicleCount >= THRESH_GO;
  const wallStable = wallCount >= THRESH_GO;
  const groundStable = groundCount >= THRESH_GO;

  // prioridad original DE MENSAJES: pared > persona > veh√≠culo > obst√°culo > libre
  let msg = "Camino libre.";
  if (wallStable) msg = "Pared al frente, det√©ngase.";
  else if (personStable) msg = "Persona al frente, cuidado.";
  else if (vehicleStable) msg = "Veh√≠culo cerca, precauci√≥n.";
  else if (groundStable) msg = "Obst√°culo en el camino.";

  // s√≥lo hablar si el mensaje filtrado cambi√≥ (evita flip-flops)
  if (msg !== lastMessage) speak(msg);

  // siguiente frame
  requestAnimationFrame(detectFrame);
}

/* ---------- START ---------- */
async function startApp() {
  startBtn.style.display = "none";
  notify("Activando c√°mara‚Ä¶");

  try {
    await setupCamera();
    notify("C√°mara lista");

    await loadModels();
    notify("Asistente iniciado");

    // inicializamos contadores a 0
    personCount = vehicleCount = wallCount = groundCount = 0;
    lastMessage = "";

    requestAnimationFrame(detectFrame);
  } catch (e) {
    console.error(e);
    statusDiv.textContent = "Error cr√≠tico. Revisa permisos y consola.";
    notify("Error iniciando. Revisa permisos.");
  }
}

startBtn.addEventListener("click", startApp);
</script>
</body>
</html>
