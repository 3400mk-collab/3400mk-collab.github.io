!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Asistente Visual Inteligente - Optimizado</title>

  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' https://cdn.jsdelivr.net https://cdn.jsdelivr.net/npm 'unsafe-inline' 'unsafe-eval';
    connect-src *;
    img-src 'self' blob: data:;
    media-src *;
    style-src 'self' 'unsafe-inline';
    object-src 'none';
    frame-ancestors 'none';
  ">

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>

  <style>
    :root{--green:#2ea043}
    body{background:#0d1117;color:#fff;font-family:Segoe UI,Arial,sans-serif;margin:0;padding:18px;text-align:center}
    h1{margin:6px 0 12px;font-size:1.1rem}
    #startButton{font-size:1.1rem;padding:10px 22px;background:var(--green);border:none;border-radius:12px;color:#fff;cursor:pointer}
    video{width:90%;max-width:480px;border-radius:12px;margin-top:12px;background:#000}
    #status{margin-top:12px;display:inline-block;background:rgba(255,255,255,.08);padding:10px 14px;border-radius:10px}
    #notify{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:rgba(0,0,0,.75);padding:8px 12px;border-radius:10px;opacity:0;transition:.25s;color:#fff}
    #debugCanvas{position:fixed;right:12px;top:12px;width:160px;height:120px;border:1px solid rgba(255,255,255,.08);display:none}
  </style>
</head>
<body>
  <h1>üëÅ Asistente Visual Inteligente - Optimizado</h1>
  <button id="startButton">Iniciar Asistente</button>
  <video id="video" autoplay playsinline muted></video>
  <div id="status">Esperando inicio...</div>
  <div id="notify"></div>
  <canvas id="debugCanvas"></canvas>

<script>
const startBtn = document.getElementById('startButton');
const statusDiv = document.getElementById('status');
const notifyBox = document.getElementById('notify');
const video = document.getElementById('video');
const debugCanvas = document.getElementById('debugCanvas');
const debugCtx = debugCanvas.getContext && debugCanvas.getContext('2d');

let cocoModel = null;
let blazeModel = null;
let lastMessage = '';
let lastSpokenMessage = '';
let lastSpokenAt = 0;
let speaking = false;
let lastFrameTime = 0;

// Hysteresis counters
const COUNTER_MAX = 8;
const THRESH_GO = 2;
let personCnt = 0, vehicleCnt = 0, wallCnt = 0, obsLowCnt = 0, obsMidCnt = 0, obsHighCnt = 0;
let leftCnt = 0, centerCnt = 0, rightCnt = 0;
const ZONE_THRESH = 2;

// Object thresholds
const MIN_OBJ_AREA_RATIO = 0.002; // detecta objetos peque√±os
const GENERIC_BIG_RATIO = 0.02;
const PERSON_MIN_RATIO = 0.012;
const VEHICLE_MIN_RATIO = 0.02;
const WALL_RATIO = 0.55;

let DEBUG = false;

function notify(msg){
  notifyBox.textContent = msg;
  notifyBox.style.opacity = 1;
  setTimeout(()=> notifyBox.style.opacity = 0, 2200);
}

/* ---------- VOZ optimizada ---------- */
const voiceCooldownMs = 600;
function speak(msg){
  if(!msg) return;
  const now = performance.now();
  if(msg === lastSpokenMessage && now - lastSpokenAt < 2500) return; // evita repeticiones
  if(window.speechSynthesis.speaking) return; // no cortar frases

  const u = new SpeechSynthesisUtterance(msg);
  u.lang = 'es-MX';
  u.onend = ()=> speaking=false;
  speaking = true;
  window.speechSynthesis.speak(u);

  lastSpokenMessage = msg;
  lastSpokenAt = now;
}

/* ---------- C√°mara ---------- */
async function setupCamera(){
  const constraints = {
    audio: false,
    video: { facingMode: { ideal:'environment'}, width:{ideal:320}, height:{ideal:240}, frameRate:{ideal:15,max:20} }
  };
  try{
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    video.muted = true;
    await new Promise(res => video.onloadedmetadata=res);
    await video.play().catch(()=>{});
  }catch(e){
    notify('No se puede acceder a la c√°mara.');
    speak('No se puede usar el asistente sin c√°mara.');
    throw e;
  }
}

/* ---------- Cargar modelos ---------- */
async function loadModels(){
  statusDiv.textContent='Cargando modelos...';
  notify('Cargando modelos...');
  try{
    if(tf.setBackend) await tf.setBackend('webgl');
    await tf.ready();
    cocoModel = await cocoSsd.load({base:'lite_mobilenet_v2'});
    blazeModel = await blazeface.load();
    statusDiv.textContent='Modelos cargados ‚úî';
    notify('Modelos listos');
  }catch(e){
    console.error('Error cargando modelos', e);
    statusDiv.textContent='Error cargando modelos';
    notify('Error cargando modelos');
    throw e;
  }
}

function clamp(n,min=0,max=COUNTER_MAX){ return Math.max(min, Math.min(max,n)); }
function obstacleLevels(obj,vw,vh){
  const [x,y,w,h]=obj.bbox;
  const area = w*h;
  const bottom = y+h;
  const lowZone = vh*0.7;
  const midZoneTop = vh*0.35;
  const highZone = vh*0.25;
  const low = (bottom>lowZone) && (area>vw*vh*0.008);
  const mid = ((y+h/2)>midZoneTop && (y+h/2)<=lowZone) && (area>vw*vh*0.008);
  const high = (y<highZone) && (area>vw*vh*0.006);
  return {low,mid,high};
}

function zoneOccupancyFromPreds(preds,vw,vh){
  let left=false,center=false,right=false;
  const zoneAreaThr = Math.max(GENERIC_BIG_RATIO,0.01)*vw*vh;
  for(const obj of preds){
    const [x,y,w,h]=obj.bbox;
    const area=w*h;
    const cx=x+w/2;
    const zone=(cx<vw/3)?'left':(cx>2*vw/3)?'right':'center';
    if(area>=zoneAreaThr){
      if(zone==='left') left=true;
      else if(zone==='center') center=true;
      else if(zone==='right') right=true;
    }
  }
  return {left,center,right};
}

/* ---------- Loop principal ---------- */
async function detectLoop(ts){
  if(!ts) ts=performance.now();
  const RATE_MS=170;
  if(ts-lastFrameTime<RATE_MS) return requestAnimationFrame(detectLoop);
  lastFrameTime=ts;
  if(!cocoModel || !blazeModel) return requestAnimationFrame(detectLoop);

  let cocoDet=[],blazeDet=[];
  try{
    cocoDet = await cocoModel.detect(video);
    blazeDet = await blazeModel.estimateFaces(video,false);
  }catch(e){ return requestAnimationFrame(detectLoop); }

  const preds = [...cocoDet];
  blazeDet.forEach(face=>preds.push({class:'person',score:0.9,bbox:[
    face.topLeft[0], face.topLeft[1],
    face.bottomRight[0]-face.topLeft[0],
    face.bottomRight[1]-face.topLeft[1]
  ]}));

  const vw=video.videoWidth||320;
  const vh=video.videoHeight||240;

  // Flags
  let personPresent=false,vehiclePresent=false,wallPresent=false;
  let anyLow=false,anyMid=false,anyHigh=false;
  let genericObstacle=false,bigFurniture=false;

  const FURNITURE_CLASSES=new Set(['chair','couch','sofa','bed','dining table','table','door','bench','wardrobe','tv']);

  for(const obj of preds){
    const [x,y,w,h]=obj.bbox;
    const area=w*h;
    const areaRatio=area/(vw*vh);
    if(obj.class==='person' && areaRatio>Math.max(PERSON_MIN_RATIO,12000/(vw*vh))) personPresent=true;
    if(['car','truck','bus','motorcycle','bicycle'].includes(obj.class) && areaRatio>VEHICLE_MIN_RATIO) vehiclePresent=true;
    if(areaRatio>WALL_RATIO) wallPresent=true;
    if(FURNITURE_CLASSES.has(obj.class) && areaRatio>GENERIC_BIG_RATIO) bigFurniture=true;
    if(areaRatio>=MIN_OBJ_AREA_RATIO) genericObstacle=true;

    const lv=obstacleLevels(obj,vw,vh);
    if(lv.low) anyLow=true;
    if(lv.mid) anyMid=true;
    if(lv.high) anyHigh=true;
  }

  const zones=zoneOccupancyFromPreds(preds,vw,vh);
  leftCnt=clamp(zones.left?leftCnt+1:leftCnt-1);
  centerCnt=clamp(zones.center?centerCnt+1:centerCnt-1);
  rightCnt=clamp(zones.right?rightCnt+1:rightCnt-1);
  const leftStable=leftCnt>=ZONE_THRESH;
  const centerStable=centerCnt>=ZONE_THRESH;
  const rightStable=rightCnt>=ZONE_THRESH;

  personCnt=clamp(personPresent?personCnt+1:personCnt-1);
  vehicleCnt=clamp(vehiclePresent?vehicleCnt+1:vehicleCnt-1);
  wallCnt=clamp(wallPresent?wallCnt+1:wallCnt-1);
  obsLowCnt=clamp(anyLow?obsLowCnt+1:obsLowCnt-1);
  obsMidCnt=clamp(anyMid?obsMidCnt+1:obsMidCnt-1);
  obsHighCnt=clamp(anyHigh?obsHighCnt+1:obsHighCnt-1);

  const personStable=personCnt>=THRESH_GO;
  const vehicleStable=vehicleCnt>=THRESH_GO;
  const wallStable=wallCnt>=THRESH_GO;
  const lowStable=obsLowCnt>=THRESH_GO;
  const midStable=obsMidCnt>=THRESH_GO;
  const highStable=obsHighCnt>=THRESH_GO;

  // Mensaje
  let message='Camino libre.';
  if(wallStable) message='Pared al frente, det√©ngase.';
  else if(personStable) message='Persona al frente, cuidado.';
  else if(vehicleStable) message='Veh√≠culo cerca, precauci√≥n.';
  else if(highStable) message='Objeto alto al frente ‚Äî cuidado.';
  else if(midStable) message='Objeto a media altura al frente ‚Äî cuidado.';
  else if(lowStable) message='Objeto en el suelo obstruyendo el paso.';
  else if(bigFurniture && genericObstacle) message='Obst√°culo grande al frente (mueble/puerta) ‚Äî cuidado.';
  else if(genericObstacle) message='Objeto detectado al frente.';
  else {
    if(centerStable){
      if(!leftStable && rightStable) message='Centro ocupado. Intenta ir por la izquierda.';
      else if(!rightStable && leftStable) message='Centro ocupado. Intenta ir por la derecha.';
      else if(!leftStable && !rightStable) message='Centro ocupado. Izquierda y derecha libres, gira con cuidado.';
      else message='Centro y laterales ocupados, detente y espera.';
    }
  }

  if(preds.length>0 && message==='Camino libre.') message=lastMessage || 'Camino libre.'; // patch libre

  if(message!==lastMessage){lastMessage=message; statusDiv.textContent=message;}

  const now=performance.now();
  const isDanger=message!=='Camino libre.';
  if(isDanger){
    if(message!==lastSpokenMessage) speak(message);
  }else{
    if(lastSpokenMessage!=='Camino libre.'){
      if(now-lastSpokenAt>voiceCooldownMs && !(personCnt||wallCnt||vehicleCnt||obsLowCnt||obsMidCnt||obsHighCnt)) speak(message);
    }else{
      if(now-lastSpokenAt>Math.max(800,voiceCooldownMs)) speak(message);
    }
  }

  if(DEBUG && debugCtx){
    debugCanvas.style.display='block';
    debugCanvas.width=320; debugCanvas.height=240;
    debugCtx.clearRect(0,0,debugCanvas.width,debugCanvas.height);
    debugCtx.strokeStyle='rgba(0,255,0,0.6)';
    debugCtx.lineWidth=1;
    preds.slice(0,8).forEach(p=>{
      const [x,y,w,h]=p.bbox;
      const sx=x*(debugCanvas.width/vw);
      const sy=y*(debugCanvas.height/vh);
      const sw=w*(debugCanvas.width/vw);
      const sh=h*(debugCanvas.height/vh);
      debugCtx.strokeRect(sx,sy,sw,sh);
      debugCtx.fillStyle='rgba(0,255,0,0.06)';
      debugCtx.fillRect(sx,sy,sw,sh);
    });
  }

  requestAnimationFrame(detectLoop);
}

/* ---------- Inicio app ---------- */
async function startApp(){
  startBtn.disabled=true; startBtn.style.opacity='0.6';
  notify('Solicitando c√°mara...'); statusDiv.textContent='Solicitando c√°mara...';
  try{
    await setupCamera();
    notify('C√°mara activada'); statusDiv.textContent='C√°mara lista';
    await loadModels();

    personCnt=vehicleCnt=wallCnt=obsLowCnt=obsMidCnt=obsHighCnt=0;
    leftCnt=centerCnt=rightCnt=0;
    lastMessage=''; lastSpokenMessage=''; lastSpokenAt=0;

    notify('Asistente iniciado'); statusDiv.textContent='Asistente iniciado';
    requestAnimationFrame(detectLoop);
  }catch(e){
    console.error(e);
    statusDiv.textContent='Error cr√≠tico. Revisa permisos/consola.';
    notify('No se pudo iniciar.');
    startBtn.disabled=false; startBtn.style.opacity='1';
  }
}

startBtn.addEventListener('click',startApp);
</script>
</body>
</html>