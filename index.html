<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Asistente Visual Inteligente - Versi√≥n A (r√°pida, B: suavizado)</title>

  <!-- CSP segura compatible con TFJS para GitHub Pages -->
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' https://cdn.jsdelivr.net https://cdn.jsdelivr.net/npm 'unsafe-inline' 'unsafe-eval';
    connect-src *;
    img-src 'self' blob: data:;
    media-src *;
    style-src 'self' 'unsafe-inline';
    object-src 'none';
    frame-ancestors 'none';
  ">

  <!-- TensorFlow.js y modelos -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>

  <style>
    :root{--green:#2ea043}
    body{background:#0d1117;color:#fff;font-family:Segoe UI,Arial,sans-serif;margin:0;padding:18px;text-align:center}
    h1{margin:6px 0 12px;font-size:1.1rem}
    #startButton{font-size:1.1rem;padding:10px 22px;background:var(--green);border:none;border-radius:12px;color:#fff;cursor:pointer}
    video{width:90%;max-width:480px;border-radius:12px;margin-top:12px;background:#000}
    #status{margin-top:12px;display:inline-block;background:rgba(255,255,255,.08);padding:10px 14px;border-radius:10px}
    #notify{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;background:rgba(0,0,0,.75);padding:8px 12px;border-radius:10px;opacity:0;transition:.25s;color:#fff}
    #debugCanvas{position:fixed;right:12px;top:12px;width:160px;height:120px;border:1px solid rgba(255,255,255,.08);display:none}
  </style>
</head>

<body>
  <h1>üëÅ Asistente Visual Inteligente (Versi√≥n A - B: suavizado)</h1>
  <button id="startButton">Iniciar Asistente</button>
  <video id="video" autoplay playsinline muted></video>
  <div id="status">Esperando inicio...</div>
  <div id="notify"></div>
  <canvas id="debugCanvas"></canvas>

<script>
/* =============================
   VERSI√ìN A + SUAVIZADO B COMPLETO
   ============================= */

const startBtn = document.getElementById('startButton');
const statusDiv = document.getElementById('status');
const notifyBox = document.getElementById('notify');
const video = document.getElementById('video');
const debugCanvas = document.getElementById('debugCanvas');
const debugCtx = debugCanvas.getContext && debugCanvas.getContext('2d');

let cocoModel = null;
let blazeModel = null;
let lastMessage = '';
let lastSpokenMessage = '';
let lastSpokenAt = 0;
let speaking = false;
let lastFrameTime = 0;

const COUNTER_MAX = 8;
const THRESH_GO = 2;
let personCnt = 0, vehicleCnt = 0, wallCnt = 0;
let obsLowCnt = 0, obsMidCnt = 0, obsHighCnt = 0;

let leftCnt=0, centerCnt=0, rightCnt=0;
const ZONE_THRESH = 2;

const MIN_OBJ_AREA_RATIO = 0.008;
const GENERIC_BIG_RATIO = 0.02;
const PERSON_MIN_RATIO = 0.012;
const VEHICLE_MIN_RATIO = 0.02;
const WALL_RATIO = 0.55;

let DEBUG = false;

function notify(msg){
  notifyBox.textContent = msg;
  notifyBox.style.opacity = 1;
  setTimeout(()=> notifyBox.style.opacity = 0, 2200);
}

const voiceCooldownMs = 600;
function speak(msg){
  if(!msg) return;
  const now = performance.now();

  if(msg === lastSpokenMessage && (now - lastSpokenAt) < 1000) return;

  if(msg === 'Camino libre.') {
    if(lastSpokenMessage && lastSpokenMessage !== 'Camino libre.' &&
       (now - lastSpokenAt) < voiceCooldownMs) return;
  }

  try {
    if(window.speechSynthesis && window.speechSynthesis.speaking){
      window.speechSynthesis.cancel();
    }
    const u = new SpeechSynthesisUtterance(msg);
    u.lang='es-MX';
    speaking=true;
    u.onend=()=> speaking=false;
    window.speechSynthesis.speak(u);
    lastSpokenMessage = msg;
    lastSpokenAt = now;
    statusDiv.textContent = msg;
  }catch(e){}
}

async function setupCamera(){
  const constraints = {
    audio:false,
    video:{
      facingMode:{ideal:'environment'},
      width:{ideal:320},
      height:{ideal:240},
      frameRate:{ideal:15,max:20}
    }
  };
  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  video.srcObject = stream;
  await new Promise(res=>video.onloadedmetadata=res);
  await video.play();
}

async function loadModels(){
  statusDiv.textContent='Cargando modelos...';
  if(tf && tf.setBackend){
    try{ await tf.setBackend('webgl'); } catch(e){}
  }
  await tf.ready();
  cocoModel = await cocoSsd.load({base:'lite_mobilenet_v2'});
  blazeModel = await blazeface.load();
  statusDiv.textContent='Modelos cargados ‚úî';
}

function clamp(n,min=0,max=COUNTER_MAX){return Math.max(min,Math.min(max,n));}

function obstacleLevels(obj,vw,vh){
  const [x,y,w,h]=obj.bbox;
  const area = w*h;
  const bottom=y+h;

  const lowZone = vh*0.70;
  const midZoneTop = vh*0.35;
  const highZone = vh*0.25;

  const low = bottom>lowZone && area>(vw*vh*0.008);
  const mid = (y+h/2)>midZoneTop && (y+h/2)<=lowZone && area>(vw*vh*0.008);
  const high = y<highZone && area>(vw*vh*0.006);

  return{low,mid,high};
}

function zoneOccupancyFromPreds(preds,vw,vh){
  let left=false,center=false,right=false;
  const zoneAreaThr=Math.max(GENERIC_BIG_RATIO,0.01)*vw*vh;
  for(const obj of preds){
    const [x,y,w,h]=obj.bbox;
    const area=w*h;
    if(area<zoneAreaThr) continue;
    const cx=x+w/2;
    const zone=(cx<vw/3)?'left':(cx>2*vw/3)?'right':'center';
    if(zone==='left') left=true;
    else if(zone==='center') center=true;
    else if(zone==='right') right=true;
  }
  return{left,center,right};
}

async function detectLoop(ts){
  if(!ts) ts=performance.now();

  const RATE_MS=170;
  if(ts-lastFrameTime < RATE_MS) return requestAnimationFrame(detectLoop);
  lastFrameTime = ts;

  if(!cocoModel||!blazeModel) return requestAnimationFrame(detectLoop);

  let cocoDet=[], blazeDet=[];
  try{
    cocoDet = await cocoModel.detect(video);
    blazeDet = await blazeModel.estimateFaces(video,false);
  }catch(e){
    return requestAnimationFrame(detectLoop);
  }

  const preds=[...cocoDet];
  blazeDet.forEach(face=>{
    preds.push({
      class:'person', score:0.9,
      bbox:[
        face.topLeft[0],
        face.topLeft[1],
        face.bottomRight[0]-face.topLeft[0],
        face.bottomRight[1]-face.topLeft[1]
      ]
    });
  });

  const vw=video.videoWidth||320;
  const vh=video.videoHeight||240;

  let person=false, vehicle=false, wall=false;
  let anyLow=false, anyMid=false, anyHigh=false;
  let genericObstacle=false, bigFurniture=false;

  const FURNITURE_CLASSES=new Set([
    'chair','couch','sofa','bed','dining table','table','door','bench','wardrobe','tv'
  ]);

  for(const obj of preds){
    const [x,y,w,h]=obj.bbox;
    const area=w*h;
    const ratio=area/(vw*vh);

    if(obj.class==='person' && ratio>Math.max(PERSON_MIN_RATIO,12000/(vw*vh))) person=true;
    if(['car','truck','bus','motorcycle','bicycle'].includes(obj.class)&& ratio>VEHICLE_MIN_RATIO) vehicle=true;
    if(ratio>WALL_RATIO) wall=true;
    if(FURNITURE_CLASSES.has(obj.class)&& ratio>GENERIC_BIG_RATIO) bigFurniture=true;
    if(ratio>=MIN_OBJ_AREA_RATIO) genericObstacle=true;

    const lv = obstacleLevels(obj,vw,vh);
    if(lv.low) anyLow=true;
    if(lv.mid) anyMid=true;
    if(lv.high) anyHigh=true;
  }

  const zones = zoneOccupancyFromPreds(preds,vw,vh);
  leftCnt = clamp(zones.left?leftCnt+1:leftCnt-1);
  centerCnt = clamp(zones.center?centerCnt+1:centerCnt-1);
  rightCnt = clamp(zones.right?rightCnt+1:rightCnt-1);

  const L = leftCnt>=ZONE_THRESH;
  const C = centerCnt>=ZONE_THRESH;
  const R = rightCnt>=ZONE_THRESH;

  personCnt=clamp(person?personCnt+1:personCnt-1);
  vehicleCnt=clamp(vehicle?vehicleCnt+1:vehicleCnt-1);
  wallCnt=clamp(wall?wallCnt+1:wallCnt-1);
  obsLowCnt=clamp(anyLow?obsLowCnt+1:obsLowCnt-1);
  obsMidCnt=clamp(anyMid?obsMidCnt+1:obsMidCnt-1);
  obsHighCnt=clamp(anyHigh?obsHighCnt+1:obsHighCnt-1);

  const p=personCnt>=THRESH_GO;
  const v=vehicleCnt>=THRESH_GO;
  const wll=wallCnt>=THRESH_GO;
  const low=obsLowCnt>=THRESH_GO;
  const mid=obsMidCnt>=THRESH_GO;
  const high=obsHighCnt>=THRESH_GO;

  let message='Camino libre.';

  if(wll) message='Pared al frente, det√©ngase.';
  else if(p) message='Persona al frente, cuidado.';
  else if(v) message='Veh√≠culo cerca, precauci√≥n.';
  else if(high) message='Objeto alto al frente ‚Äî cuidado.';
  else if(mid) message='Objeto a media altura al frente ‚Äî cuidado.';
  else if(low) message='Objeto en el suelo obstruyendo el paso.';
  else if(bigFurniture && genericObstacle) message='Obst√°culo grande al frente ‚Äî cuidado.';
  else if(genericObstacle) message='Objeto detectado al frente.';
  else {
    if(C){
      if(!L && R) message='Centro ocupado. Puedes intentar ir por la izquierda.';
      else if(!R && L) message='Centro ocupado. Puedes intentar ir por la derecha.';
      else if(!L && !R) message='Centro ocupado. Izquierda y derecha parecen libres.';
      else message='Centro ocupado y laterales tambi√©n ocupados, det√©ngase.';
    }
  }

  if(message!==lastMessage){
    lastMessage=message;
    statusDiv.textContent=message;
  }

  const now=performance.now();
  const danger = message!=='Camino libre.';

  if(danger){
    if(message!==lastSpokenMessage) speak(message);
  } else {
    const dt = now - lastSpokenAt;
    if(lastSpokenMessage==='Camino libre.'){
      if(dt>Math.max(800,voiceCooldownMs)) speak(message);
    } else {
      if(dt>voiceCooldownMs){
        if(!(personCnt>0 || wallCnt>0 || vehicleCnt>0 ||
             obsLowCnt>0||obsMidCnt>0||obsHighCnt>0)){
          speak(message);
        }
      }
    }
  }

  requestAnimationFrame(detectLoop);
}

async function startApp(){
  startBtn.disabled=true;
  notify('Solicitando c√°mara...');
  statusDiv.textContent='Solicitando c√°mara...';

  try{
    await setupCamera();
    notify('C√°mara activada');
    statusDiv.textContent='C√°mara activada';

    await loadModels();
    notify('Modelos listos');
    statusDiv.textContent='Modelos cargados ‚úî';

    lastMessage='';
    lastSpokenMessage='';
    lastSpokenAt=0;

    notify('Asistente iniciado');
    statusDiv.textContent='Asistente iniciado';

    requestAnimationFrame(detectLoop);
  }catch(e){
    console.error(e);
    statusDiv.textContent='Error cr√≠tico. Revisa permisos.';
  }
}

startBtn.addEventListener('click',startApp);
</script>

</body>
</html>
